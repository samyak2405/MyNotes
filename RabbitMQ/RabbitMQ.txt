JMS
	- Java Messaging Service
	- While sending a message their is a producer and consumer.
	- Producer cannot send msgs directly to consumer
	- We use a intermediator such as a message broker to send msgs.
	- Whatever msgs are coming from producer are being routed through exchange and queue and then it will go to the consumers.
	- Exchange and queue are part of RabbitMQ message broker.
	- Exchange
		- Route the message to the respective queue
		Types of Exchange
			- Direct
			- Fanout
			- Topic
			- Headers
		Note: Each of these exchange as its own way of working and how it routes the messages to the queues.
			  All depends on the binding between the exchange and the queue.

RabbitMQ and Erlang/OTP Installation
	Windows
	RabbitMQ- http://www/rabbitmq.com/download.html
	Erlang/OTP- http://www.erlang.org/downloads
	
	1. Install Erlang first(otp)
	2. Set C:\Program Files\erxx.x in environment variable path.
	3. Advanced System settings->Environment variable->New System Variable
		Variable name: ERLANG_HOME
		Variable value: path in 2
		Edit Path variable: append %ERLANG_HOME%\bin ->OK ->Apply
	4. Extract RabbitMQ zip
	5. Go inside RabbitMQ->Data->rabbitmq_server-version->sbin
	6. Enable RabbitMQ Management Plugins
		Open CMD
		$rabbitmq-plugins.bat enable rabbitmq_management
	7. In the same folder run rabbitmq-server file
	8. Once server is up hit the url in browser
		localhost:15672
	9. Username: guest
		password: guest
	
	Ubuntu
	1. sudo apt install curl
	2. curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.deb.sh | sudo bash
	3. sudo apt update
    4. sudo apt-get install rabbitmq-server
	5. systemctl start rabbitmq-server
	6. systemctl status rabbitmq-server
	7. sudo rabbitmq-plugins enable rabbitmq_management
	8. sudo rabbitmqctl add_user admin1 admin123
	9. sudo rabbitmqctl set_user_tags admin1 administrator
	10. sudo systemctl stop rabbitmq-server.service
	
1. Purge the message
	Assume that in some situation, we have some bunch of messages in the ready state in your queue, but you don't want to consume those messages.
	So if you start your consumers, then it will reach to your consumers and your business logic will get executed for those messages.
	To avoid this situation, you have to remove all the ready messages from the queue.
	This is called as purge in RabbitMQ.
	Achieved in two ways	
		1. Using GUI
			Click on Queue name->(In bottom) Select purge->Purge Message
		2. Using CLI
			In Windows
				Go to the directory: RabbitMQ->Data->rabbitmq_server-version->sbin
				Run: >rabbitmqctl.bat purge_queue Queue-1
			In Ubuntu
				$wget http://localhost:15672/cli/rabbitmqadmin
				$chmod +x rabbitmqadmin
				$./rabbitmqadmin purge queue name=Queue-1

2. Real Time Example
	Lets say we have a REST API which serves export to Excel functionality. Lets say one user is 
	requesting that Excel, which can have thousands of records inside it. Now within that rest API,
	if we write the business logic and we query over the DB and we create the Excel file and we send 
	it back to the user in the rest response itself, then it will slow down the performance of our 
	REST API. Instead of that what we can do is that we can create the JSON message and we can put 
	the required attributes like some filter parameters that is requested by the user, like from date 
	to date. We can also put the email address of the user who requested that excel. Now we can publish 
	this JSON message to the queue. So in REST API we can response back to user saying that we have received 
	your request for the export to Excel and you will recieve an email. Now from Queue, the JSON message 
	will reach the consumer. Now in consumer we can extract the information from the JSON Message. We can query over 
	the DB and we can write the business logic to create the Excel file and we can write the logic to send out 
	an email to the user. Attaching the Excel file. Now, just assume that if thousands of users are requesting
	this kind of Excel file, which can have thousands of records inside it, and if we write all this logic inside
	our Rest API itself, then it will slow down the performance of our application.
			